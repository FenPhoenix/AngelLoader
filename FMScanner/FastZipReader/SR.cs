// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Runtime.CompilerServices;

namespace FMScanner.FastZipReader
{
    internal static class SR
    {
        #region Strings

        // I don't know how the heck this is supposed to work, but these fields must be autogenerated at some
        // point. I don't know where or how, so I autogenerated them myself. English-only of course, but... meh.
        // TODO: Figure out if these strings can be made translatable or whatever the heck you're supposed to do
        internal const string ArgumentOutOfRange_Enum = "Enum value was out of legal range.";
        internal const string ArgumentOutOfRange_NeedPosNum = "Positive number required.";
        internal const string CannotReadFromDeflateStream = "Reading from the compression stream is not supported.";
        internal const string CannotWriteToDeflateStream = "Writing to the compression stream is not supported.";
        internal const string GenericInvalidData = "Found invalid data while decoding.";
        internal const string InvalidArgumentOffsetCount = "Offset plus count is larger than the length of target array.";
        internal const string InvalidBeginCall = "Only one asynchronous reader or writer is allowed time at one time.";
        internal const string InvalidBlockLength = "Block length does not match with its complement.";
        internal const string InvalidHuffmanData = "Failed to construct a huffman tree using the length array. The stream might be corrupted.";
        internal const string NotSupported = "This operation is not supported.";
        internal const string NotSupported_UnreadableStream = "Stream does not support reading.";
        internal const string NotSupported_UnwritableStream = "Stream does not support writing.";
        internal const string ObjectDisposed_StreamClosed = "Cannot access a closed stream.";
        internal const string UnknownBlockType = "Unknown block type. Stream might be corrupted.";
        internal const string UnknownState = "Decoder is in some unknown state. This might be caused by corrupted data.";
        internal const string ZLibErrorDLLLoadError = "The underlying compression routine could not be loaded correctly.";
        internal const string ZLibErrorInconsistentStream = "The stream state of the underlying compression routine is inconsistent.";
        internal const string ZLibErrorIncorrectInitParameters = "The underlying compression routine received incorrect initialization parameters.";
        internal const string ZLibErrorNotEnoughMemory = "The underlying compression routine could not reserve sufficient memory.";
        internal const string ZLibErrorVersionMismatch = "The version of the underlying compression routine does not match expected version.";
        internal const string ZLibErrorUnexpected = "The underlying compression routine returned an unexpected error code.";
        internal const string ArgumentNeedNonNegative = "The argument must be non-negative.";
        internal const string CannotBeEmpty = "String cannot be empty.";
        internal const string CDCorrupt = "Central Directory corrupt.";
        internal const string CentralDirectoryInvalid = "Central Directory is invalid.";
        internal const string CreateInReadMode = "Cannot create entries on an archive opened in read mode.";
        internal const string CreateModeCapabilities = "Cannot use create mode on a non-writable stream.";
        internal const string CreateModeCreateEntryWhileOpen = "Entries cannot be created while previously created entries are still open.";
        internal const string CreateModeWriteOnceAndOneEntryAtATime = "Entries in create mode may only be written to once, and only one entry may be held open at a time.";
        internal const string DateTimeOutOfRange = "The DateTimeOffset specified cannot be converted into a Zip file timestamp.";
        internal const string DeletedEntry = "Cannot modify deleted entry.";
        internal const string DeleteOnlyInUpdate = "Delete can only be used when the archive is in Update mode.";
        internal const string DeleteOpenEntry = "Cannot delete an entry currently open for writing.";
        internal const string EntriesInCreateMode = "Cannot access entries in Create mode.";
        internal const string EntryNameEncodingNotSupported = "The specified entry name encoding is not supported.";
        internal const string EntryNamesTooLong = "Entry names cannot require more than 2^16 bits.";
        internal const string EntryTooLarge = "Entries larger than 4GB are not supported in Update mode.";
        internal const string EOCDNotFound = "End of Central Directory record could not be found.";
        internal const string FieldTooBigCompressedSize = "Compressed Size cannot be held in an Int64.";
        internal const string FieldTooBigLocalHeaderOffset = "Local Header Offset cannot be held in an Int64.";
        internal const string FieldTooBigNumEntries = "Number of Entries cannot be held in an Int64.";
        internal const string FieldTooBigOffsetToCD = "Offset to Central Directory cannot be held in an Int64.";
        internal const string FieldTooBigOffsetToZip64EOCD = "Offset to Zip64 End Of Central Directory record cannot be held in an Int64.";
        internal const string FieldTooBigStartDiskNumber = "Start Disk Number cannot be held in an Int64.";
        internal const string FieldTooBigUncompressedSize = "Uncompressed Size cannot be held in an Int64.";
        internal const string FrozenAfterWrite = "Cannot modify entry in Create mode after entry has been opened for writing.";
        internal const string HiddenStreamName = "A stream from ZipArchiveEntry has been disposed.";
        internal const string LengthAfterWrite = "Length properties are unavailable once an entry has been opened for writing.";
        internal const string LocalFileHeaderCorrupt = "A local file header is corrupt.";
        internal const string NumEntriesWrong = "Number of entries expected in End Of Central Directory does not correspond to number of entries in Central Directory.";
        internal const string OffsetLengthInvalid = "The offset and length parameters are not valid for the array that was given.";
        internal const string ReadingNotSupported = "This stream from ZipArchiveEntry does not support reading.";
        internal const string ReadModeCapabilities = "Cannot use read mode on a non-readable stream.";
        internal const string ReadOnlyArchive = "Cannot modify read-only archive.";
        internal const string SeekingNotSupported = "This stream from ZipArchiveEntry does not support seeking.";
        internal const string SetLengthRequiresSeekingAndWriting = "SetLength requires a stream that supports seeking and writing.";
        internal const string SplitSpanned = "Split or spanned archives are not supported.";
        internal const string UnexpectedEndOfStream = "Zip file corrupt: unexpected end of stream reached.";
        internal const string UnsupportedCompression = "The archive entry was compressed using an unsupported compression method.";
        internal const string UnsupportedCompressionMethod = "The archive entry was compressed using {0} and is not supported.";
        internal const string UpdateModeCapabilities = "Update mode requires a stream with read, write, and seek capabilities.";
        internal const string UpdateModeOneStream = "Entries cannot be opened multiple times in Update mode.";
        internal const string WritingNotSupported = "This stream from ZipArchiveEntry does not support writing.";
        internal const string Zip64EOCDNotWhereExpected = "Zip 64 End of Central Directory Record not where indicated.";
        internal const string Argument_InvalidPathChars = "Illegal characters in path '{0}'.";


        #endregion

        // This method is used to decide if we need to append the exception message parameters to the message when calling SR.Format. 
        // by default it returns false.
        // Native code generators can replace the value this returns based on user input at the time of native code generation.
        // Marked as NoInlining because if this is used in an AoT compiled app that is not compiled into a single file, the user
        // could compile each module with a different setting for this. We want to make sure there's a consistent behavior
        // that doesn't depend on which native module this method got inlined into.
        [MethodImpl(MethodImplOptions.NoInlining)]
        private static bool UsingResourceKeys()
        {
            return false;
        }

        internal static string Format(string resourceFormat, params object[] args)
        {
            if (args != null)
            {
                if (UsingResourceKeys())
                {
                    return resourceFormat + string.Join(", ", args);
                }

                return string.Format(resourceFormat, args);
            }

            return resourceFormat;
        }

        internal static string Format(string resourceFormat, object p1)
        {
            if (UsingResourceKeys())
            {
                return string.Join(", ", resourceFormat, p1);
            }

            return string.Format(resourceFormat, p1);
        }

        internal static string Format(string resourceFormat, object p1, object p2)
        {
            if (UsingResourceKeys())
            {
                return string.Join(", ", resourceFormat, p1, p2);
            }

            return string.Format(resourceFormat, p1, p2);
        }

        internal static string Format(string resourceFormat, object p1, object p2, object p3)
        {
            if (UsingResourceKeys())
            {
                return string.Join(", ", resourceFormat, p1, p2, p3);
            }

            return string.Format(resourceFormat, p1, p2, p3);
        }
    }
}