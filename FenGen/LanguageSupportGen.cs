using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static FenGen.Misc;

namespace FenGen
{
    internal static class LanguageSupport
    {
        private sealed class LanguageEnum
        {
            internal string Name = "";
            internal string LanguageIndexName = "";
            internal readonly List<string> LangEnumNames = new List<string>();
            internal readonly List<string> LangIndexEnumNames = new List<string>();
            internal readonly List<string> LangIndexEnumNamesLowercase = new List<string>();
            internal readonly List<string> LangCodes = new List<string>();
            internal readonly List<string> LangTranslatedNames = new List<string>();
        }

        internal static void Generate(string source, string dest)
        {
            var langEnum = ReadSourceFile(source);
            WriteDestFile(dest, langEnum);
        }

        private static LanguageEnum ReadSourceFile(string file)
        {
            var ret = new LanguageEnum();

            string code = File.ReadAllText(file);
            SyntaxTree tree = ParseTextFast(code);

            var d = GetAttrMarkedItem(tree, SyntaxKind.EnumDeclaration, GenAttributes.FenGenLanguageEnum);
            var langEnum = (EnumDeclarationSyntax)d.Member;
            AttributeSyntax langEnumAttr = d.Attribute;
            if (langEnumAttr.ArgumentList == null || langEnumAttr.ArgumentList.Arguments.Count == 0)
            {
                ThrowErrorAndTerminate(nameof(GenAttributes.FenGenLanguageEnum) + " had 0 args");
            }

            ret.LanguageIndexName = ((LiteralExpressionSyntax)langEnumAttr.ArgumentList!.Arguments[0].Expression).Token.ValueText;
            ret.Name = langEnum.Identifier.ToString().Trim();

            for (int i = 0; i < langEnum.Members.Count; i++)
            {
                var member = langEnum.Members[i];
                string memberName = member.Identifier.ToString();
                ret.LangEnumNames.Add(memberName);
                if (!HasAttribute(member, GenAttributes.FenGenIgnore))
                {
                    ret.LangIndexEnumNames.Add(memberName);
                    ret.LangIndexEnumNamesLowercase.Add(memberName.ToLowerInvariant());

                    AttributeSyntax? langAttr = member
                        .AttributeLists[0]
                        .Attributes
                        .FirstOrDefault(x => x.Name.ToString() == GenAttributes.FenGenLanguage);

                    if (langAttr != null)
                    {
                        if (langAttr.ArgumentList == null || langAttr.ArgumentList.Arguments.Count < 2)
                        {
                            ThrowErrorAndTerminate(nameof(GenAttributes.FenGenLanguage) + " had < 2 args");
                        }

                        string codeArg =
                            ((LiteralExpressionSyntax)langAttr.ArgumentList!.Arguments[0].Expression).Token
                            .ValueText;
                        string translatedNameArg =
                            ((LiteralExpressionSyntax)langAttr.ArgumentList!.Arguments[1].Expression).Token
                            .ValueText;

                        ret.LangCodes.Add(codeArg);
                        ret.LangTranslatedNames.Add(translatedNameArg);
                    }
                }
            }

            return ret;
        }

        private static void WriteDestFile(string destFile, LanguageEnum langEnum)
        {
            var w = GetWriterForClass(destFile, GenAttributes.FenGenLanguageSupportDestClass);

            int count = langEnum.LangIndexEnumNames.Count;

            w.WL("#region Autogenerated language support code");
            w.WL();

            w.WL("public enum " + langEnum.LanguageIndexName + " : uint");
            WriteListBody(w, langEnum.LangIndexEnumNames, isEnum: true);

            w.WL("public static HashSetI LangsHash = new HashSetI(" + count + ")");
            WriteListBody(w, langEnum.LangIndexEnumNamesLowercase, addQuotes: true);

            w.WL("public static DictionaryI<" + langEnum.LanguageIndexName + "> LangStringsToEnums = new(" + count + ")");
            var values = new List<string>(count);
            foreach (var lang in langEnum.LangIndexEnumNames)
            {
                values.Add(langEnum.LanguageIndexName + "." + lang);
            }
            WriteDictionaryBody(w, langEnum.LangIndexEnumNamesLowercase, values, keysQuoted: true);

            var codeValues = new List<string>();
            foreach (string codeItem in langEnum.LangCodes)
            {
                string[] codes = codeItem.Split(new[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                string value = "new[] { ";
                for (int i = 0; i < codes.Length; i++)
                {
                    string code = codes[i];
                    value += "\"" + code + "\"" + (i < codes.Length - 1 ? ", " : " ");
                }
                value += "}";
                codeValues.Add(value);
            }
            w.WL("public static DictionaryI<string[]> LangCodes = new DictionaryI<string[]>(" + count + ")");
            WriteDictionaryBody(w, langEnum.LangIndexEnumNamesLowercase, codeValues, keysQuoted: true, valuesQuoted: false);

            w.WL("public static DictionaryI<string> LangTranslatedNames = new DictionaryI<string>(" + count + ")");
            WriteDictionaryBody(w, langEnum.LangIndexEnumNamesLowercase, langEnum.LangTranslatedNames, keysQuoted: true, valuesQuoted: true);

            w.WL("#endregion");

            w.CloseClassAndNamespace();

            File.WriteAllText(destFile, w.ToString());
        }
    }
}
