using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;

namespace FenGen
{
    internal static class ExcludeResx
    {
        const string ItemGroupName = "ItemGroup";

        internal static void GenerateRestore()
        {
            var xml = new XmlDocument { PreserveWhitespace = true };
            xml.Load(Core.ALProjectFile);

            XmlNodeList itemGroups = xml.GetElementsByTagName(ItemGroupName);

            for (var i = 0; i < itemGroups.Count; i++)
            {
                XmlNode itemGroup = itemGroups[i];
                foreach (XmlNode cn in itemGroup)
                {
                    if (cn is XmlComment commentNode)
                    {
                        if (commentNode.InnerText.Trim() == GenAttributes.FenGenExcludeResx)
                        {
                            commentNode.ParentNode!.ParentNode!.RemoveChild(itemGroup);
                            i--;
                            break;
                        }
                    }
                }
            }

            WriteXml(xml);
        }

        internal static void GenerateExclude()
        {
            // In case our temp ItemGroup got left there due to the build process not fully completing or whatever
            // else have you, just remove it again so we know we're clean.
            GenerateRestore();

            var resxFilesToExclude = Directory.GetFiles(Core.ALProjectPath, "*.resx", SearchOption.AllDirectories)
                .Where(x => !Path.GetFileName(x).EqualsI("Resources.resx")).ToArray();

            const string embeddedResourceName = "EmbeddedResource";
            const string conditionString = "'$(Configuration)' != 'Debug'";
            const string conditionName = "Condition";
            const string removeName = "Remove";

            var xml = new XmlDocument { PreserveWhitespace = true };
            xml.Load(Core.ALProjectFile);

            var itemGroups = xml.GetElementsByTagName(embeddedResourceName);
            if (itemGroups.Count <= 0) return;

            var newNodes = new List<XmlNode>();

            XmlNode projNode = xml.GetElementsByTagName("Project")[0];

            XmlElement tempItemGroup = xml.CreateElement(ItemGroupName);
            foreach (string exclude in resxFilesToExclude)
            {
                XmlElement excludeElem = xml.CreateElement(embeddedResourceName);
                var condAttr = xml.CreateAttribute(conditionName);
                condAttr.Value = conditionString;
                var removeAttr = xml.CreateAttribute(removeName);
                removeAttr.Value = exclude.Substring(Core.ALProjectPath.Length).TrimStart('/', '\\');
                excludeElem.SetAttributeNode(condAttr);
                excludeElem.SetAttributeNode(removeAttr);

                newNodes.Add(excludeElem);
            }

            for (int i = 0; i < newNodes.Count; i++)
            {
                XmlNode n = newNodes[i];
                tempItemGroup.PrependChild(n);
                // We have to manually add linebreaks and indents
                tempItemGroup.InsertBefore(xml.CreateWhitespace("    "), n);
                tempItemGroup.InsertAfter(xml.CreateWhitespace("\r\n"), n);
            }
            // Prepend in reverse order
            tempItemGroup.PrependChild(xml.CreateWhitespace("\r\n"));
            tempItemGroup.PrependChild(xml.CreateComment("\r\n" +
                "        This is a temporary ItemGroup generated by FenGen to exclude .resx files on compile.\r\n" +
                "        If you can see this, something probably went wrong and you should delete this item group\r\n" +
                "        to prevent crashes and chaotic behavior when editing forms.\r\n    "));
            tempItemGroup.PrependChild(xml.CreateWhitespace("\r\n    "));
            tempItemGroup.PrependChild(xml.CreateComment(GenAttributes.FenGenExcludeResx));
            tempItemGroup.PrependChild(xml.CreateWhitespace("\r\n    "));

            projNode.AppendChild(tempItemGroup);
            projNode.AppendChild(xml.CreateWhitespace("\r\n"));

            WriteXml(xml);
        }

        private static void WriteXml(XmlDocument xml)
        {
            List<string> lines;
            using (var strW = new StringWriter())
            {
                var settings = new XmlWriterSettings { Encoding = Encoding.UTF8, OmitXmlDeclaration = true };
                using (var xmlWriter = XmlWriter.Create(strW, settings))
                {
                    xml.Save(xmlWriter);
                }

                lines = strW
                    .ToString()
                    .Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None)
                    .ToList();
            }

            // Remove consecutive whitespace lines (leaving only one-in-a-row at most).
            // This gets rid of the garbage left behind from removing the old nodes (whitespace lines).
            for (int i = 0; i < lines.Count; i++)
            {
                if (lines[i].IsWhiteSpace())
                {
                    for (int j = i + 1; j < lines.Count; j++)
                    {
                        if (lines[j].IsWhiteSpace())
                        {
                            lines.RemoveAt(j);
                            j--;
                            i--;
                        }
                        else
                        {
                            break;
                        }
                    }
                }
            }

            using var sw = new StreamWriter(Core.ALProjectFile, append: false, Encoding.UTF8);
            for (int i = 0; i < lines.Count; i++)
            {
                if (i == lines.Count - 1)
                {
                    sw.Write(lines[i]);
                }
                else
                {
                    sw.WriteLine(lines[i]);
                }
            }
        }
    }
}
