// FenGen - Fen's code generator for AngelLoader
// Not perfect by any means, and still with lots of hardcoded stuff that shouldn't be, but it gets the job done.

//#define PROFILING

using System;
using System.Collections.Generic;
using System.IO;
using System.Windows.Forms;
using JetBrains.Annotations;
using static FenGen.Misc;

namespace FenGen
{
    internal static class GenMessages
    {
        internal const string Method = @"// This method was autogenerated for maximum performance at runtime.";
        internal const string SupportingCode = @"// This supporting code was autogenerated.";
    }

    internal sealed class GameSourceEnum
    {
        internal string Name = "";
        internal readonly List<string> GameEnumNames = new List<string>();
        internal readonly List<string> GameIndexEnumNames = new List<string>();
        internal readonly List<string> GamePrefixes = new List<string>();
    }

    // TODO: Nasty global state that's really just here to avoid over-parameterization.
    internal static class Cache
    {
        private static string _gameSupportFile = "";
        internal static void SetGameSupportFile(string file) => _gameSupportFile = file;
        private static GameSourceEnum? _gamesEnum;
        internal static GameSourceEnum GamesEnum => _gamesEnum ??= Games.FillGamesEnum(_gameSupportFile);

        internal static void Clear()
        {
            _gameSupportFile = "";
            _gamesEnum = null;
        }
    }

    internal static class GenAttributes
    {
        #region Serialization

        internal const string FenGenFMDataSourceClass = nameof(FenGenFMDataSourceClass);
        internal const string FenGenIgnore = nameof(FenGenIgnore);
        internal const string FenGenIniName = nameof(FenGenIniName);
        internal const string FenGenNumericEmpty = nameof(FenGenNumericEmpty);
        internal const string FenGenListType = nameof(FenGenListType);
        internal const string FenGenListDistinctType = nameof(FenGenListDistinctType);
        internal const string FenGenDoNotTrimValue = nameof(FenGenDoNotTrimValue);
        internal const string FenGenDoNotConvertDateTimeToLocal = nameof(FenGenDoNotConvertDateTimeToLocal);
        internal const string FenGenInsertAfter = nameof(FenGenInsertAfter);

        #endregion

        #region Localizable text

        internal const string FenGenLocalizationSourceClass = nameof(FenGenLocalizationSourceClass);
        internal const string FenGenLocalizationDestClass = nameof(FenGenLocalizationDestClass);
        internal const string FenGenComment = nameof(FenGenComment);
        internal const string FenGenBlankLine = nameof(FenGenBlankLine);

        #endregion

        #region Game support

        internal const string FenGenGameEnum = nameof(FenGenGameEnum);
        internal const string FenGenNotAGameType = nameof(FenGenNotAGameType);
        internal const string FenGenGamePrefixes = nameof(FenGenGamePrefixes);

        #endregion

        internal const string FenGenExcludeResx = nameof(FenGenExcludeResx);
    }

    internal static class Core
    {
        private enum GenType
        {
            FMData,
            Config,
            Language,
            GameSupport,
            VisLoc,
            ExcludeResx,
            RestoreResx
        }

        private static class GenTaskArgs
        {
            internal const string FMData = "-fmdata";
            internal const string Language = "-language";
            internal const string LanguageAndTest = "-language_t";
            internal const string GameSupport = "-game_support";
            internal const string ExcludeResx = "-exclude_resx";
            internal const string RestoreResx = "-restore_resx";
        }

        private static class GenFileTags
        {
            internal const string LocalizationSource = "FenGen_LocalizationSource";
            internal const string LocalizationDest = "FenGen_LocalizationDest";
            internal const string GameSupport = "FenGen_GameSupport";
            internal const string FMDataSource = "FenGen_FMDataSource";
            internal const string FMDataDest = "FenGen_FMDataDest";
        }

        private static readonly int _genTaskCount = Enum.GetValues(typeof(GenType)).Length;

#if DEBUG
        private static Forms.MainForm View;
#endif

        internal static readonly string ALSolutionPath = Path.GetFullPath(Path.Combine(Application.StartupPath, @"..\..\..\..\"));
        internal static readonly string ALProjectPath = Path.GetFullPath(Path.Combine(Application.StartupPath, @"..\..\..\..\AngelLoader"));
        internal static readonly string ALProjectFile = Path.Combine(ALProjectPath, "AngelLoader.csproj");

        // PERF_TODO: Roslyn is so slow it's laughable. It takes 1.5 seconds just to run InitWorkspaceStuff() alone.
        // That's not even counting doing any actual work with it, which adds even more slug time.
        // Go back to manually doing it all, and just organize AL so the gen can find things without too much
        // brittleness.
        // -ParseText() seems to have like a 200ms init time the first time you call it. See what I goddamn mean.

        internal static void Init()
        {
#if Release
            ReadArgsAndDoTasks();

            Environment.Exit(0);
#else
            View = new Forms.MainForm();
            View.Show();
#endif
        }

        private static void ExitIfRelease() => Environment.Exit(1);

        [PublicAPI]
        internal static void ReadArgsAndDoTasks()
        {
            try
            {
                ReadArgsAndDoTasksInternal();
            }
            catch (Exception ex)
            {
                ThrowErrorAndTerminate(ex);
            }
            finally
            {
                Cache.Clear();
            }
        }

        private static void ReadArgsAndDoTasksInternal()
        {
            // args[0] is always the application filename

#if PROFILING
            string[] args =
            {
                Environment.GetCommandLineArgs()[0],
                GenTaskArgs.FMData,
                GenTaskArgs.LanguageAndTest,
                GenTaskArgs.ExcludeResx,
                GenTaskArgs.RestoreResx
            };
#else
            string[] args = Environment.GetCommandLineArgs();
#endif

            if (args.Length < 2) ExitIfRelease();

            bool generateLangTestFile = false;

            bool[] _genTasksActive = new bool[_genTaskCount];

            #region Local functions

            void SetGenTaskActive(GenType genType) => _genTasksActive[(int)genType] = true;

            bool GenTaskActive(GenType genType) => _genTasksActive[(int)genType];

            bool AnyGenTasksActive()
            {
                for (int i = 0; i < _genTasksActive.Length; i++)
                {
                    if (_genTasksActive[i]) return true;
                }
                return false;
            }

            #endregion

            for (int i = 1; i < args.Length; i++)
            {
                switch (args[i])
                {
                    case GenTaskArgs.FMData:
                        SetGenTaskActive(GenType.FMData);
                        break;
                    case GenTaskArgs.Language:
                    case GenTaskArgs.LanguageAndTest:
                        SetGenTaskActive(GenType.Language);
                        generateLangTestFile = args[i] == GenTaskArgs.LanguageAndTest;
                        break;
                    case GenTaskArgs.GameSupport:
                        SetGenTaskActive(GenType.GameSupport);
                        break;
                    case GenTaskArgs.ExcludeResx:
                        SetGenTaskActive(GenType.ExcludeResx);
                        break;
                    case GenTaskArgs.RestoreResx:
                        SetGenTaskActive(GenType.RestoreResx);
                        break;
                }

                if (!AnyGenTasksActive())
                {
                    ExitIfRelease();
                    return;
                }
            }

            var genFileTags = new List<string>();
            bool gameSupportRequested = GenTaskActive(GenType.FMData) || GenTaskActive(GenType.GameSupport);
            if (gameSupportRequested)
            {
                genFileTags.Add(GenFileTags.GameSupport);
            }
            if (GenTaskActive(GenType.FMData))
            {
                genFileTags.Add(GenFileTags.FMDataSource);
                genFileTags.Add(GenFileTags.FMDataDest);
            }
            if (GenTaskActive(GenType.Language))
            {
                genFileTags.Add(GenFileTags.LocalizationSource);
                genFileTags.Add(GenFileTags.LocalizationDest);
            }

            Dictionary<string, string>? taggedFilesDict = null;
            if (genFileTags.Count > 0)
            {
                taggedFilesDict = FindRequiredCodeFiles(genFileTags);
            }

            if (gameSupportRequested)
            {
                Cache.SetGameSupportFile(taggedFilesDict![GenFileTags.GameSupport]);
            }

            if (GenTaskActive(GenType.FMData))
            {
                FMData.Generate(
                    taggedFilesDict![GenFileTags.FMDataSource],
                    taggedFilesDict![GenFileTags.FMDataDest]);
            }
            if (GenTaskActive(GenType.Language))
            {
                string englishIni = Path.Combine(ALProjectPath, @"Languages\English.ini");
                string testLangIni = generateLangTestFile
                    ? @"C:\AngelLoader\Data\Languages\TestLang.ini"
                    : "";
                Language.Generate(
                    taggedFilesDict![GenFileTags.LocalizationSource],
                    taggedFilesDict![GenFileTags.LocalizationDest],
                    englishIni,
                    testLangIni);
            }
            if (GenTaskActive(GenType.GameSupport))
            {
                Games.Generate();
            }
            if (GenTaskActive(GenType.ExcludeResx))
            {
                ExcludeResx.GenerateExclude();
            }
            if (GenTaskActive(GenType.RestoreResx))
            {
                ExcludeResx.GenerateRestore();
            }
        }

        [MustUseReturnValue]
        private static Dictionary<string, string>
        FindRequiredCodeFiles(List<string> genFileTags)
        {
            var taggedFiles = new List<string>[genFileTags.Count];
            for (int i = 0; i < taggedFiles.Length; i++)
            {
                taggedFiles[i] = new List<string>();
            }

            string[] files = Directory.GetFiles(ALProjectPath, "*.cs", SearchOption.AllDirectories);
            foreach (string f in files)
            {
                using var sr = new StreamReader(f);

                string line;
                while ((line = sr.ReadLine()) != null)
                {
                    string lts = line.TrimStart();
                    if (lts.IsWhiteSpace() || lts.StartsWith("//")) continue;

                    if (lts[0] != '#') break;

                    if (lts.StartsWith("#define") && lts.Length > 7 && char.IsWhiteSpace(lts[7]))
                    {
                        string tag = lts.Substring(7).Trim();

                        for (int i = 0; i < genFileTags.Count; i++)
                        {
                            string genFileTag = genFileTags[i];
                            if (tag == genFileTag)
                            {
                                taggedFiles[i].Add(f);
                                break;
                            }
                        }
                    }
                }
            }

            #region Error reporting

            static string AddError(string msg, string add)
            {
                if (msg.IsEmpty()) msg = "ERRORS:";
                msg += "\r\n" + add;
                return msg;
            }

            string error = "";
            for (int i = 0; i < taggedFiles.Length; i++)
            {
                if (taggedFiles[i].Count == 0)
                {
                    error = AddError(error, "-No file found with '#define " + genFileTags[i] + "' at top");
                }
                else if (taggedFiles[i].Count > 1)
                {
                    error = AddError(error, "-Multiple files found with '#define " + genFileTags[i] + "' at top");
                }
            }
            if (!error.IsEmpty()) ThrowErrorAndTerminate(error);

            #endregion

            var ret = new Dictionary<string, string>();
            for (int i = 0; i < genFileTags.Count; i++)
            {
                ret.Add(genFileTags[i], taggedFiles[i][0]);
            }
            return ret;
        }
    }
}
